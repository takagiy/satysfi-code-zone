@require: pervasives
@require: vdecoset
@require: option
@require: color
@require: math
@require: list
@import: sized-list
@import: seqsplit

type code-zone-wrap-method =
  Textual | Free | WrapMethod of context -> string -> inline-boxes

type code-zone-style = (|
  sep : length;
  frame : deco-set;
  wrap-method : code-zone-wrap-method;
  number-sep : length;
  number-sep-text : inline-text;
  number-sep-text-trailing : inline-text;
  number-font : (string * float * float) option;
  number-frame: deco-set;
  code-sep : length;
  code-font : string * float * float;
  code-frame : deco-set;
|)

module CodeZone : sig
  direct +code-of : [code-zone-style; string] block-cmd
  direct +code : [string] block-cmd
  val default-style : code-zone-style
end = struct
  let-inline ctx \as-wide-as norm it =
    let horz-norm = read-inline ctx norm in
    let horz-it = read-inline ctx it in
    let width-diff =
      let norm-width = get-natural-width horz-norm in
      let it-width = get-natural-width horz-it in
      norm-width -' it-width
    in
    inline-skip (width-diff *' 0.5) ++ horz-it
      ++ inline-skip (width-diff *' 0.5)

  let eol = string-unexplode [0x0A]

  let default-style = (|
    sep = 2pt;
    frame = VDecoSet.empty;
    wrap-method = Free;
    number-sep = 6pt;
    number-sep-text = {};
    number-sep-text-trailing = {};
    number-font = None;
    number-frame = VDecoSet.empty;
    code-sep = 2pt;
    code-font = (`lmmono`, 1., 0.);
    code-frame = VDecoSet.empty; %VDecoSet.simple-frame-stroke 0.5pt Color.black;
  |)

  let split-by-delimiter d s =
    let-rec aux maxlen len =
      let sub = string-sub s in
      if len >= maxlen then
        (s, None)
      else if string-same (sub len 1) d then
        ((sub 0 len), Some(sub (len + 1) (maxlen - len - 1)))
      else
        aux maxlen (len + 1)
    in
      aux (string-length s) 0

  let-rec string-lines s =
    open SizedList in
    match split-by-delimiter eol s with
    | (head, Some(tail)) -> head +: string-lines tail
    | (head, None)       -> head +: nil

  let-rec drop-empty-lines lst =
  match lst with
  | x :: xs ->
      if string-length x == 0 then
        drop-empty-lines xs
      else
        lst
  | []      -> []

  let ( => ) f g x = g (f x)

  let-rec fold-left-n n f zero elem =
    if n == 0 then
      zero
    else
      f (fold-left-n (n - 1) f zero elem) elem

  let get-number-width sty number ctx =
    let digit-width = [{0}; {1}; {2}; {3}; {4}; {5}; {6}; {7}; {8}; {9}]
      |> List.map (read-inline ctx => get-natural-width)
      |> List.fold-left length-max 0pt
    in
    digit-width *' float (string-length (arabic number))
      +' get-natural-width (read-inline ctx sty#number-sep-text)
        +' sty#number-sep

  let line-break-subpage ctx width (padl, padr) horz =
    inline-skip padl
      ++ embed-block-top ctx (width -' padl -' padr)
        (fun ctx -> line-break true true ctx (horz ctx))
          ++ inline-skip padr

  let force-break ctx =
    discretionary 0 (inline-skip ((get-text-width ctx) *' 2.)) inline-nil
      inline-nil

  let make-number-horz ctx sty width trailing-depth number =
    let horz-leading =
      let horz-number =
        read-inline ctx (embed-string (arabic number)) ++ read-inline ctx
          sty#number-sep-text
      in
      inline-fil ++ horz-number
    in
    let horz-trailing =
      let horz-empty-number = read-inline ctx sty#number-sep-text-trailing in
      inline-fil ++ horz-empty-number
    in
    let num-trailing = round (trailing-depth /' get-font-size ctx) in
    let ( +/+ ) l r = l ++ force-break ctx ++ r in
    fold-left-n num-trailing (+/+) horz-leading horz-trailing

  let make-number ctx sty width trailing-depth number =
    line-break-subpage ctx width (0pt, sty#number-sep) (fun ctx ->
      make-number-horz ctx sty width trailing-depth number)

  let make-context sty number-width ctx =
    let font-size = get-font-size ctx in
    let ctx = ctx
      |> set-paragraph-margin (font-size *' 0.25) 0pt
      |> set-min-gap-of-lines (font-size *' 0.)
      |> set-leading (font-size *' 1.)
    in
    let number-context = ctx
      |> set-font Latin (Option.from (get-font Latin ctx) sty#number-font)
    in
    let code-context =
      let ctx = ctx
        |> set-font Latin sty#code-font
        |> set-hyphen-penalty 100000
      in
      let char-width = get-natural-width (read-inline ctx {0}) in
      ctx |> set-space-ratio (char-width /' font-size) 0. 0.
    in
    (number-context, code-context)

  let compound-deco sty nw f n c (x, y) width height depth =
    List.concat [
      f (x, y) width height depth;
      n (x, y) nw height depth;
      c (x +' nw +' sty#sep, y) (width -' nw -' sty#sep) height depth;
    ]

  let compound-deco-set number-width sty =
    match (sty#frame, sty#number-frame, sty#code-frame) with
    | ((f0, f1, f2, f3), (n0, n1, n2, n3), (c0, c1, c2, c3)) ->
      (
        compound-deco sty number-width f0 n0 c0,
        compound-deco sty number-width f1 n1 c1,
        compound-deco sty number-width f2 n2 c2,
        compound-deco sty number-width f3 n3 c3
      )

  let code-scheme-prior-info ctx sty code =
    let (number-context, _) = make-context sty 0pt ctx in
    let (code-line-count, code-lines) = string-lines code in
    let number-width =
      get-number-width sty code-line-count number-context
    in
    (|
      code-lines = code-lines;
      number-width = number-width;
    |)

  let append-fil horz = horz ++ inline-fil

  let-rec resolve-wrap-method
    | ctx (Textual)       = embed-string => read-inline ctx
    | ctx (Free)          = Seqsplit.embed-string-breakable ctx
    | ctx (WrapMethod(m)) = m ctx

  let code-scheme pre ctx sty code =
    let (number-context, code-context) =
      make-context sty pre#number-width ctx
    in
    pre#code-lines
      |> drop-empty-lines
      |> List.mapi (fun number code-line -> (
        let horz-code-line =
          line-break-subpage code-context
            (get-text-width ctx -' pre#number-width)
              (sty#code-sep, sty#code-sep) (fun ctx ->
                code-line |> resolve-wrap-method code-context sty#wrap-method
                          |> append-fil)
        in
        let horz-number =
          let (_, _, trailing-depth) = get-natural-metrics horz-code-line in
          make-number number-context sty pre#number-width trailing-depth number
        in
        line-break true true code-context
          (horz-number ++ horz-code-line ++ inline-fil)))
      |> List.fold-left (+++) block-nil

  let-block ctx +code-of sty code =
    let pre = code-scheme-prior-info ctx sty code in
    block-frame-breakable ctx
      (sty#sep, length-max sty#sep sty#code-sep, sty#sep, sty#sep)
        (compound-deco-set pre#number-width sty)
          (fun ctx -> code-scheme pre ctx sty code)

  let-block +code code = '<+code-of(default-style)(code);>
end
